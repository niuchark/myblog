import{_ as i,c as a,a as e,o as n}from"./app-Cwg-pqKw.js";const t={};function l(p,s){return n(),a("div",null,s[0]||(s[0]=[e(`<div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 接收聊天消息（包括自己发出后返回的消息）</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">  socket</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">on</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">receiveChatMsg</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> async</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">event</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    list</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">push</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">event</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    await</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> nextTick</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 简单理解为DOM更新后触发，执行完nextTick()后也代表DOM更新完成了</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 通过 nextTick 方法，我们可以确保在 DOM 更新完成后执行某些操作。</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    window</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">scrollTo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> document</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">body</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">scrollHeight</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  })</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在做即时通讯项目时，有发送消息后解决窗口自动下滑的需求</p><p>在 Vue.js 中，有一个特殊的方法 nextTick，它在 DOM 更新后执行一段代码，起到等待 DOM 绘制完成的作用。</p><h2 id="nexttick-的定义" tabindex="-1"><a class="header-anchor" href="#nexttick-的定义"><span>$nextTick 的定义</span></a></h2><p>𝑛𝑒𝑥𝑡𝑇𝑖𝑐𝑘方法将回调函数延迟到下次𝐷𝑂𝑀更新循环结束之后执行。在𝑉𝑢𝑒.𝑗𝑠中，由于𝐷𝑂𝑀的更新是异步的，所以当数据发生变化时，𝐷𝑂𝑀不会立即更新，而是在下一个“𝑡𝑖𝑐𝑘”（即𝑉𝑢𝑒的𝐷𝑂𝑀更新周期）中统一进行更新。因此，如果你需要在数据变化后立即访问更新后的𝐷𝑂𝑀，就需要使用nextTick 方法。</p><p>简单的说，nextTick 方法是在 Vue.js 中常见的一种异步更新 DOM 的机制。它的原理是利用 Js 的事件循环机制以及浏览器的渲染流程来实现延迟执行 DOM 更新操作。</p><p>它的出现主要是为了解决 Vue 的异步更新导致的 DOM 更新后的操作问题。</p><p>在 Vue 中，数据的变化会触发重新渲染 DOM，但实际上，Vue 的数据更新是异步的。也就是说，当我们修改了 Vue 实例的数据后，并不会立即进行 DOM 更新，而是在下一个事件循环中才会进行。</p><p>这个异步更新机制的设计是为了优化性能。Vue 会对进行多次数据变化进行合并，然后在下一个事件循环中进行一次性的 DOM 更新，从而减少不必要的 DOM 操作，提高性能。</p><p>然而，由于异步更新的机制，有时候可能在修改数据后需要立即执行一些 DOM 操作，例如获取到更新后的 DOM 元素、更新后的样式计算、触发一些特定事件等。这时候就需要使用 nextTick 方法了。</p><p>使用 nextTick 方法经常用来解决以下问题：</p><ul><li><p>获取更新后的 DOM 元素</p></li><li><p>更新后的样式计算</p></li><li><p>触发一些特定事件</p></li></ul><p>————————————————</p><p>原文链接：https://blog.csdn.net/sunyctf/article/details/145663221 <br><br><br></p><h2 id="关于上方代码中的window-scrollto函数" tabindex="-1"><a class="header-anchor" href="#关于上方代码中的window-scrollto函数"><span>关于上方代码中的window.scrollTo函数</span></a></h2><p>‌<a href="https://www.baidu.com/s?rsv_dl=re_dqa_generate&amp;sa=re_dqa_generate&amp;wd=window.scrollTo&amp;rsv_pq=daca00b1006c2e06&amp;oq=window.scrollTo&amp;rsv_t=e8f4R24qilwD4EktIXeCp67IPV7unL3rI7sG6TAqSXVqFGXJhIEBupphQ4o&amp;tn=baidu&amp;ie=utf-8" target="_blank" rel="noopener noreferrer">window.scrollTo</a>‌ 方法用于将浏览器窗口滚动到指定的坐标位置。该方法有两种调用方式：</p><ol><li>‌<strong>直接指定坐标</strong>‌：使用 <code>window.scrollTo(xpos, ypos)</code>，其中 <code>xpos</code> 和 <code>ypos</code> 分别表示窗口文档显示区左上角的 x 和 y 坐标‌1。例如，<code>window.scrollTo(0, 0)</code> 会将页面滚动到顶部。</li><li>‌<strong>使用选项对象</strong>‌：使用 <code>window.scrollTo({left: xpos, top: ypos, behavior})</code>，其中 <code>left</code> 和 <code>top</code> 分别表示 x 和 y 坐标，<code>behavior</code> 可以设置为 <code>smooth</code>（平滑滚动）或 <code>instant</code>（瞬间滚动），默认值为 <code>auto</code>‌23。例如，<code>window.scrollTo({left: 0, top: 100, behavior: &quot;smooth&quot;})</code> 会平滑滚动到页面顶部100像素的位置。</li></ol><h2 id="平滑滚动到页面顶部" tabindex="-1"><a class="header-anchor" href="#平滑滚动到页面顶部"><span>平滑滚动到页面顶部</span></a></h2><p>可以通过以下方式实现平滑滚动到页面顶部：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>javascriptCopy Codefunction scrollToTop() {</span></span>
<span class="line"><span>  const c = document.documentElement.scrollTop || document.body.scrollTop;</span></span>
<span class="line"><span>  if (c &gt; 0) {</span></span>
<span class="line"><span>    window.requestAnimationFrame(scrollToTop);</span></span>
<span class="line"><span>    window.scrollTo(0, c - c / 8);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>scrollToTop();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,20)]))}const r=i(t,[["render",l]]),o=JSON.parse('{"path":"/home/p2dbvck9/","title":"nextTick方法","lang":"zh-CN","frontmatter":{"title":"nextTick方法","createTime":"2025/08/08 21:29:19","permalink":"/home/p2dbvck9/","description":"在做即时通讯项目时，有发送消息后解决窗口自动下滑的需求 在 Vue.js 中，有一个特殊的方法 nextTick，它在 DOM 更新后执行一段代码，起到等待 DOM 绘制完成的作用。 $nextTick 的定义 𝑛𝑒𝑥𝑡𝑇𝑖𝑐𝑘方法将回调函数延迟到下次𝐷𝑂𝑀更新循环结束之后执行。在𝑉𝑢𝑒.𝑗𝑠中，由于𝐷𝑂𝑀的更新是...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"nextTick方法\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-04T13:00:18.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://niuck.cn/home/p2dbvck9/"}],["meta",{"property":"og:site_name","content":"宁采柯的小窝"}],["meta",{"property":"og:title","content":"nextTick方法"}],["meta",{"property":"og:description","content":"在做即时通讯项目时，有发送消息后解决窗口自动下滑的需求 在 Vue.js 中，有一个特殊的方法 nextTick，它在 DOM 更新后执行一段代码，起到等待 DOM 绘制完成的作用。 $nextTick 的定义 𝑛𝑒𝑥𝑡𝑇𝑖𝑐𝑘方法将回调函数延迟到下次𝐷𝑂𝑀更新循环结束之后执行。在𝑉𝑢𝑒.𝑗𝑠中，由于𝐷𝑂𝑀的更新是..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-04T13:00:18.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-04T13:00:18.000Z"}]]},"readingTime":{"minutes":2.82,"words":847},"git":{"createdTime":1754660802000,"updatedTime":1756990818000,"contributors":[{"name":"niuchark","username":"niuchark","email":"3248234300@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/niuchark?v=4","url":"https://github.com/niuchark"},{"name":"niuchangkang","username":"niuchangkang","email":"niuchangkang@telrobot.top","commits":2,"avatar":"https://avatars.githubusercontent.com/niuchangkang?v=4","url":"https://github.com/niuchangkang"}]},"autoDesc":true,"filePathRelative":"notes/home/2.学习笔记/1.Vue/1.nextTick.md","headers":[]}');export{r as comp,o as data};
