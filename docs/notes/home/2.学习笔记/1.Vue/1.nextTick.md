---
title: nextTick方法
createTime: 2025/08/08 21:29:19
permalink: /home/p2dbvck9/
---

```js
// 接收聊天消息（包括自己发出后返回的消息）
  socket.on('receiveChatMsg', async (event) => {
    list.value.push(event)
    await nextTick() // 简单理解为DOM更新后触发，执行完nextTick()后也代表DOM更新完成了
    // 通过 nextTick 方法，我们可以确保在 DOM 更新完成后执行某些操作。
    window.scrollTo(0, document.body.scrollHeight)
  })
})
```


在做即时通讯项目时，有发送消息后解决窗口自动下滑的需求

在 Vue.js 中，有一个特殊的方法 nextTick，它在 DOM 更新后执行一段代码，起到等待 DOM 绘制完成的作用。

## $nextTick 的定义
𝑛𝑒𝑥𝑡𝑇𝑖𝑐𝑘方法将回调函数延迟到下次𝐷𝑂𝑀更新循环结束之后执行。在𝑉𝑢𝑒.𝑗𝑠中，由于𝐷𝑂𝑀的更新是异步的，所以当数据发生变化时，𝐷𝑂𝑀不会立即更新，而是在下一个“𝑡𝑖𝑐𝑘”（即𝑉𝑢𝑒的𝐷𝑂𝑀更新周期）中统一进行更新。因此，如果你需要在数据变化后立即访问更新后的𝐷𝑂𝑀，就需要使用nextTick 方法。

简单的说，nextTick 方法是在 Vue.js 中常见的一种异步更新 DOM 的机制。它的原理是利用 Js 的事件循环机制以及浏览器的渲染流程来实现延迟执行 DOM 更新操作。

它的出现主要是为了解决 Vue 的异步更新导致的 DOM 更新后的操作问题。

在 Vue 中，数据的变化会触发重新渲染 DOM，但实际上，Vue 的数据更新是异步的。也就是说，当我们修改了 Vue 实例的数据后，并不会立即进行 DOM 更新，而是在下一个事件循环中才会进行。

这个异步更新机制的设计是为了优化性能。Vue 会对进行多次数据变化进行合并，然后在下一个事件循环中进行一次性的 DOM 更新，从而减少不必要的 DOM 操作，提高性能。

然而，由于异步更新的机制，有时候可能在修改数据后需要立即执行一些 DOM 操作，例如获取到更新后的 DOM 元素、更新后的样式计算、触发一些特定事件等。这时候就需要使用 nextTick 方法了。

使用 nextTick 方法经常用来解决以下问题：

- 获取更新后的 DOM 元素

- 更新后的样式计算

- 触发一些特定事件

————————————————

原文链接：https://blog.csdn.net/sunyctf/article/details/145663221
<br/>
<br/>
<br/>

## 关于上方代码中的window.scrollTo函数
‌[window.scrollTo](https://www.baidu.com/s?rsv_dl=re_dqa_generate&sa=re_dqa_generate&wd=window.scrollTo&rsv_pq=daca00b1006c2e06&oq=window.scrollTo&rsv_t=e8f4R24qilwD4EktIXeCp67IPV7unL3rI7sG6TAqSXVqFGXJhIEBupphQ4o&tn=baidu&ie=utf-8)‌ 方法用于将浏览器窗口滚动到指定的坐标位置。该方法有两种调用方式：

1. ‌**直接指定坐标**‌：使用 `window.scrollTo(xpos, ypos)`，其中 `xpos` 和 `ypos` 分别表示窗口文档显示区左上角的 x 和 y 坐标‌1。例如，`window.scrollTo(0, 0)` 会将页面滚动到顶部。
2. ‌**使用选项对象**‌：使用 `window.scrollTo({left: xpos, top: ypos, behavior})`，其中 `left` 和 `top` 分别表示 x 和 y 坐标，`behavior` 可以设置为 `smooth`（平滑滚动）或 `instant`（瞬间滚动），默认值为 `auto`‌23。例如，`window.scrollTo({left: 0, top: 100, behavior: "smooth"})` 会平滑滚动到页面顶部100像素的位置。

## 平滑滚动到页面顶部

可以通过以下方式实现平滑滚动到页面顶部：

```
javascriptCopy Codefunction scrollToTop() {
  const c = document.documentElement.scrollTop || document.body.scrollTop;
  if (c > 0) {
    window.requestAnimationFrame(scrollToTop);
    window.scrollTo(0, c - c / 8);
  }
}
scrollToTop();
```